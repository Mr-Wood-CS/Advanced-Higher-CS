# Binary Searching

!!! info "What you need to Know"

	Describe, exemplify, and implement binary search
	
	Read and explain code that uses constructs appropriate to this level.

## Explanantion

A binary search finds a value by continually halving a sorted list until a target is, or is not, found.

The code begins by designating a start (S) point and an end (E) point in the list. These are initially the first and last elements of the array.

From these, the target value positioned in the middle of the sorted list is identified":

==( M=(E-S)/2 )==.

> image to be added

The algorithm compares the target to the value stored at M and makes one of three decisions:

1. If the middle value is larger than the target, then the target must be in the half of the list that contains smaller values.

2. If the middle value is smaller, the target must be in the larger half of the list.

3. If the middle value is equal to the target, then the position of the target has been identified and the search ends.

If either bullet points 1 or 2 are true, then the start or end are reassigned as required. 

The middle point is then calculated for the remaining list and the same decision is made again.

> image to be added

This is carried out again, until a match is found at M.

> image to be added

## Binary Search of Sorted Integers

=== "Python"

    ``` python linenums="1"
    names = ["Alice", "Charlie", "Emma", "Jack", "Olivia", "Sophia", "Zach"]

    def binary_search(array, target):
	    left = 0
	    right = len(array) - 1
	    
	    while left <= right:
	        middle = (left + right) // 2  # Find the middle index
	        
	        middle_value = array[middle]  # Get the name at the middle index
	
	        if middle_value == target:
	            return f"{target} found at index {middle}!"
	        elif target < middle_value:
	            right = middle - 1  # Focus on the left half
	        else:
	            left = middle + 1  # Focus on the right half
	
	    return f"{target} is not in the list."

    print(binary_search(names, "Olivia"))
 
    ```

=== "Explanation"

	`Line 1`
	: Implement the array of integers (sorted)   
 
 	`Line 3`
	: The lowest index point (S) is stored
 
	`Line 3`
 
	: 
	
	
 



## Binary Search of Sorted Strings 

=== "Python"

    ``` python linenums="1"
    names = ["Alice", "Charlie", "Emma", "Jack", "Olivia", "Sophia", "Zach"]

    def binary_search(array, target):
	    left = 0
	    right = len(array) - 1
	    
	    while left <= right:
	        middle = (left + right) // 2  # Find the middle index
	        
	        middle_value = array[middle]  # Get the name at the middle index
	
	        if middle_value == target:
	            return f"{target} found at index {middle}!"
	        elif target < middle_value:
	            right = middle - 1  # Focus on the left half
	        else:
	            left = middle + 1  # Focus on the right half
	
	    return f"{target} is not in the list."

    print(binary_search(names, "Olivia"))
 
    ```

=== "Explanation"

    `Line 3 - Define the Function`
    
	: This line starts the definition of a function called insertion_sort that takes one argument, arr, which will be a list of numbers we want to sort.
   	 - This function takes two inputs:
     		- `array`: The sorted list of names to search.
    		- `target`: The name weâ€™re searching for.

    `Line 4 - Starting Point`
 
    	: Set the Starting Point 
    ``` python
    	left = 0
    ```
	
	
