# Binary Searching

!!! info "What you need to Know"

	Describe, exemplify, and implement binary search
	
	Read and explain code that uses constructs appropriate to this level.

## Explanantion

A binary search finds a value by continually halving a sorted list until a target is, or is not, found.

The code begins by designating a start (S) point and an end (E) point in the list. These are initially the first and last elements of the array.

From these, the target value positioned in the middle of the sorted list is identified":

==( M=(E-S)/2 )==.

> image to be added

The algorithm compares the target to the value stored at M and makes one of three decisions:

1. If the middle value is larger than the target, then the target must be in the half of the list that contains smaller values.

2. If the middle value is smaller, the target must be in the larger half of the list.

3. If the middle value is equal to the target, then the position of the target has been identified and the search ends.

If either bullet points 1 or 2 are true, then the start or end are reassigned as required. 

The middle point is then calculated for the remaining list and the same decision is made again.

> image to be added

This is carried out again, until a match is found at M.

> image to be added

## Binary Search of Sorted Integers

=== "Python"

    ``` python linenums="1"
    names = ["Alice", "Charlie", "Emma", "Jack", "Olivia", "Sophia", "Zach"]

    def binary_search(array, target):
	    left = 0
	    right = len(array) - 1
	    
	    while left <= right:
	        middle = (left + right) // 2  # Find the middle index
	        
	        middle_value = array[middle]  # Get the name at the middle index
	
	        if middle_value == target:
	            return f"{target} found at index {middle}!"
	        elif target < middle_value:
	            right = middle - 1  # Focus on the left half
	        else:
	            left = middle + 1  # Focus on the right half
	
	    return f"{target} is not in the list."

    print(binary_search(names, "Olivia"))
 
    ```

=== "Explanation"

	`Line 1`
	: This line starts the definition of a function called insertion_sort that takes one argument, arr, which will be a list of numbers we want to sort.
	
	`Line 3`
 
	: This loop goes through each item in the list, starting from the second item (i = 1). We don’t need to start from the first item because, by itself, it’s already "sorted."
	
	__current_number = arr[i]__
 
	Here, we store the value of the current item in the list (the one we want to sort into the right place) in a variable called current_number.
	
	__j = i - 1__
 
	We set j to be the index of the item right before current_number. This helps us compare the current_number to the items that are already sorted.
	
	__while j >= 0 and arr[j] > current_number:__
 
	This line starts a loop. It checks if j is still within the list (not less than 0) and if the item at j is bigger than current_number. If both are true, we move the item at j one position to the right. This loop makes space for current_number to be in the right spot.
	
	__arr[j + 1] = arr[j]__
 
	Inside the while loop, this line shifts the number at position j one step to the right (to position j + 1), making room for current_number to move into the correct position.
	
	__j -= 1__
 
	We move j one step to the left to check the next item in the sorted portion of the list. This repeats until current_number finds the correct position.
	
	__arr[j + 1] = current_number__
 
	Once we’ve found the correct spot for current_number, we place it there.
	
	__return arr__
 
	This line gives back the sorted list after we’ve finished the sorting.



## Binary Search of Sorted Strings 

=== "Python"

    ``` python linenums="1"
    names = ["Alice", "Charlie", "Emma", "Jack", "Olivia", "Sophia", "Zach"]

    def binary_search(array, target):
	    left = 0
	    right = len(array) - 1
	    
	    while left <= right:
	        middle = (left + right) // 2  # Find the middle index
	        
	        middle_value = array[middle]  # Get the name at the middle index
	
	        if middle_value == target:
	            return f"{target} found at index {middle}!"
	        elif target < middle_value:
	            right = middle - 1  # Focus on the left half
	        else:
	            left = middle + 1  # Focus on the right half
	
	    return f"{target} is not in the list."

    print(binary_search(names, "Olivia"))
 
    ```

=== "Explanation"

	`Line 1`
	: This line starts the definition of a function called insertion_sort that takes one argument, arr, which will be a list of numbers we want to sort.
	
	`Line 3`
 
	: This loop goes through each item in the list, starting from the second item (i = 1). We don’t need to start from the first item because, by itself, it’s already "sorted."
	
	__current_number = arr[i]__
 
	Here, we store the value of the current item in the list (the one we want to sort into the right place) in a variable called current_number.
	
	__j = i - 1__
 
	We set j to be the index of the item right before current_number. This helps us compare the current_number to the items that are already sorted.
	
	__while j >= 0 and arr[j] > current_number:__
 
	This line starts a loop. It checks if j is still within the list (not less than 0) and if the item at j is bigger than current_number. If both are true, we move the item at j one position to the right. This loop makes space for current_number to be in the right spot.
	
	__arr[j + 1] = arr[j]__
 
	Inside the while loop, this line shifts the number at position j one step to the right (to position j + 1), making room for current_number to move into the correct position.
	
	__j -= 1__
 
	We move j one step to the left to check the next item in the sorted portion of the list. This repeats until current_number finds the correct position.
	
	__arr[j + 1] = current_number__
 
	Once we’ve found the correct spot for current_number, we place it there.
	
	__return arr__
 
	This line gives back the sorted list after we’ve finished the sorting.
